---
title: Response Caching
parent: Static Routes
nav_order: 5
---

# Response Caching

Add HTTP response caching semantics (ETag, Last-Modified conditional requests and short‑lived in‑memory
caching) to static or dynamic responses to reduce bandwidth and improve perceived latency.

> Prerequisites: see [Introduction][Introduction].

## Full source

File: [`pwsh/tutorial/examples/3.5-Response-Caching.ps1`][3.5-Response-Caching.ps1]

```powershell
{% include examples/pwsh/3.5-Response-Caching.ps1 %}
```

## What this sample shows

- Registering response caching with custom size constraints
- Using `Test-KrCacheRevalidation` to automatically emit `304 Not Modified` when the request contains a
    matching `If-None-Match` (ETag) or `If-Modified-Since` header
- Emitting a stable payload + deterministic ETag hash so repeated requests are served conditionally
- Combining with existing static/file server middleware (can layer both)

## Step-by-step

1. Root + logging: Standard `Initialize-KrRoot` and console logger setup.
2. Server + listener: Create the server and add a loopback listener on port 5000.
3. File server: `Add-KrFileServerMiddleware` mounts `./Assets/wwwroot` at `/` with optional directory browsing and a
   custom content type map (`$map`). (In this sample you'll define `$map` earlier or remove if unneeded.)
4. Response caching: `Add-KrCacheMiddleware` registers the cache middleware with:
    - `-SizeLimit 10485760` → 10 MB total cache store
    - `-MaximumBodySize 65536` → responses larger than 64 KB are not cached
    - `-UseCaseSensitivePaths` → treat `/CacheTest` and `/cachetest` as distinct
    - `-SharedMaxAge 100` + `-MaxAge 100` → set freshness lifetimes
    - `-Public` → mark cacheable for shared (proxies) caches when applicable
5. Route with conditional logic: `/cachetest` computes a SHA256 hash of the stable payload; if the client
   already has the latest version (matching ETag / not modified since given date) the helper returns `$true`
   and the script block exits early (the infrastructure already wrote the 304 response). Otherwise a fresh
   body is written with `Write-KrTextResponse`.
6. Enable configuration then start the server asynchronously.

## How conditional caching works here

`Test-KrCacheRevalidation` performs logic roughly equivalent to:

1. Hash or metadata compare (the ETag you provide vs `If-None-Match`)
2. Date comparison (your supplied `-LastModified` vs `If-Modified-Since` header)
3. If either indicates the resource is unchanged it writes a `304 Not Modified` with the appropriate
   caching headers and returns `$true` so you can short‑circuit.
4. Otherwise you proceed to emit the full response and (if size limits allow) it becomes eligible for
   in‑memory caching.

You control the ETag generation; hashing the payload bytes is a simple, safe choice for immutable content.
For dynamic content consider a version stamp or aggregate change token instead of hashing full bodies.

## Try it

Start the script and issue repeated requests:

```powershell
# First request (expect 200 OK + body)
Invoke-WebRequest -Uri 'http://127.0.0.1:5000/cachetest' -Headers @{ 'Accept'='text/plain' } | Select-Object StatusCode,Headers,@{n='Len';e={$_.Content.Length}}

# Subsequent request with cached ETag automatically sent by most clients
Invoke-WebRequest -Uri 'http://127.0.0.1:5000/cachetest' | Select-Object StatusCode,Headers
```

If an ETag match occurs, the second call should show `StatusCode = 304` and no body content.

Curl example:

```bash
curl -i http://127.0.0.1:5000/cachetest
# Copy the ETag value from the response, then:
curl -i -H "If-None-Match: \"<etag from first response>\"" http://127.0.0.1:5000/cachetest
```

## Tuning parameters

| Parameter                   | Purpose                                        | Guidance                                                                |
| --------------------------- | ---------------------------------------------- | ----------------------------------------------------------------------- |
| `-SizeLimit`                | Total bytes across all cached entries          | Keep modest; very large caches increase memory pressure                 |
| `-MaximumBodySize`          | Skip caching bodies above this threshold       | Set near typical response size; prevents large blobs from evicting many |
| `-UseCaseSensitivePaths`    | Distinguish path casing                        | Useful on Linux; optional on Windows                                    |
| `-MaxAge` / `-SharedMaxAge` | Freshness lifetimes (private vs shared caches) | Short for rapidly changing content; longer for immutable assets         |
| `-Public` / `-Private`      | Cacheability scope                             | Use `-Public` only if responses are identical for all users             |

## Best practices

- Keep payload hashes stable for content that rarely changes to maximize 304 hits.
- Avoid caching highly personalized or security‑sensitive responses.
- Use a versioned path or ETag strategy when deploying updated static bundles (`app.v2.js`).
- Monitor log volume at Debug/Verbose levels; reduce when not actively diagnosing.

## Troubleshooting

| Symptom              | Cause                                  | Fix                                                              |
| -------------------- | -------------------------------------- | ---------------------------------------------------------------- |
| Always 200 responses | ETag not stable / last-mod date shifts | Ensure payload + date inputs are deterministic                   |
| No 304s with curl    | Missing `If-None-Match` header         | Provide it manually (clients add automatically after first call) |
| Large body uncached  | Exceeds `-MaximumBodySize`             | Increase threshold if appropriate                                |
| Memory growth        | Cache size too large                   | Lower `-SizeLimit` or reduce max age                             |

## Cmdlet references

- [Add-KrCacheMiddleware][Add-KrCacheMiddleware]
- [Test-KrCacheRevalidation][Test-KrCacheRevalidation]
- [Initialize-KrRoot][Initialize-KrRoot]
- [Add-KrFileServerMiddleware][Add-KrFileServerMiddleware]
- [New-KrServer][New-KrServer]
- [Add-KrListener][Add-KrListener]
- [Enable-KrConfiguration][Enable-KrConfiguration]
- [Start-KrServer][Start-KrServer]

---

### Next

{: .fs-4 .fw-500}

Previous: [Adding a Favicon](./4.Favicon)
Continue: [Variable Routes](../4.variable/index)

[3.5-Response-Caching.ps1]: /pwsh/tutorial/examples/3.5-Response-Caching.ps1
[Add-KrCacheMiddleware]: /pwsh/cmdlets/Add-KrCacheMiddleware
[Test-KrCacheRevalidation]: /pwsh/cmdlets/Test-KrCacheRevalidation
[Initialize-KrRoot]: /pwsh/cmdlets/Initialize-KrRoot
[Add-KrFileServerMiddleware]: /pwsh/cmdlets/Add-KrFileServerMiddleware
[New-KrServer]: /pwsh/cmdlets/New-KrServer
[Add-KrListener]: /pwsh/cmdlets/Add-KrListener
[Enable-KrConfiguration]: /pwsh/cmdlets/Enable-KrConfiguration
[Start-KrServer]: /pwsh/cmdlets/Start-KrServer
[Introduction]: ../1.introduction/index#prerequisites
