---
title: Client Certificate
parent: Authentication
nav_order: 8
---

# Client Certificate

Authenticate requests using client TLS certificates (mTLS).

## Full source

File: [`pwsh/tutorial/examples/8.8-Client-Certificate-Authentication.ps1`][8.8-Client-Certificate-Authentication.ps1]

```powershell
{% include examples/pwsh/8.8-Client-Certificate-Authentication.ps1 %}
```

## Step-by-step

1. Logging: Register a console logger at Debug.
2. Server: Create a server instance with [New-KrServer][New-KrServer].
3. Server cert: Create/load an HTTPS server certificate (self-signed for local testing).
4. Client cert: Create/load a client certificate (self-signed for local testing).
5. TLS validation (Kestrel): Configure HTTPS to accept dev certificates using [Set-KrServerHttpsOptions][Set-KrServerHttpsOptions].

   - Use `-ClientCertificateMode AllowCertificate` so `/info` (and probes) can work without a client certificate.
   - Provide a TLS callback using either:
     - `-ClientCertificateValidation` (built-in .NET delegate), or
     - `-ClientCertificateValidationCode` / `-ClientCertificateValidationCodePath` (compile C#/VB.NET with Roslyn).

6. Listener: Bind HTTPS using [Add-KrEndpoint][Add-KrEndpoint].
7. Authentication: Register certificate auth with [Add-KrClientCertificateAuthentication][Add-KrClientCertificateAuthentication].
8. Finalize: Apply all staged configuration using [Enable-KrConfiguration][Enable-KrConfiguration].
9. Routes: Map `/secure/cert/*` routes that require the `Certificate` scheme via [Add-KrMapRoute][Add-KrMapRoute].
10. Start: Run the server with [Start-KrServer][Start-KrServer].

### TLS vs authentication (important)

Client certificate authentication runs at the ASP.NET Core authentication layer.
Kestrel must first accept the client certificate during the TLS handshake, otherwise the request never reaches Kestrun.

## Try it

Assumptions:

- Server is listening on `https://127.0.0.1:5000`.
- Certificates are self-signed for local development.

Run the sample from the repository root:

```powershell
pwsh .\docs\_includes\examples\pwsh\8.8-Client-Certificate-Authentication.ps1
```

Public route:

```powershell
curl -k https://127.0.0.1:5000/info
```

Without a client certificate, the protected route should fail:

```powershell
try {
    Invoke-RestMethod https://127.0.0.1:5000/secure/cert/hello -SkipCertificateCheck -ErrorAction Stop
} catch {
    $_.Exception.Message
}
```

With the generated client certificate:

```powershell
$clientCertPath = '.\docs\_includes\examples\pwsh\client-cert.pfx'
$password = ConvertTo-SecureString -String 'test' -AsPlainText -Force
$cert = Import-KrCertificate -FilePath $clientCertPath -Password $password

Invoke-RestMethod https://127.0.0.1:5000/secure/cert/hello -Certificate $cert -SkipCertificateCheck
Invoke-RestMethod https://127.0.0.1:5000/secure/cert/info  -Certificate $cert -SkipCertificateCheck
```

## Troubleshooting

| Symptom                                     | Cause / Details                                                                     | Fix / Guidance                                                                 |
| ------------------------------------------- | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| Client says: "The decryption operation failed" | TLS handshake rejected the client certificate (common with self-signed certs)        | Configure Kestrel TLS callback via [Set-KrServerHttpsOptions][Set-KrServerHttpsOptions] |
| Server logs mention RemoteCertificate...    | Certificate rejected by TLS validation callback                                      | Use `AllowCertificate` + dev-friendly validation (`-ClientCertificateValidation*`) |
| "There is no Runspace available"           | TLS callback is a PowerShell script block running on Kestrel TLS threads            | Use a pure .NET delegate or compile code via `-ClientCertificateValidationCode*` |
| `/info` fails unless client cert provided   | TLS mode is `RequireCertificate`                                                    | Prefer `-ClientCertificateMode AllowCertificate` and enforce auth per-route    |
| Protected routes return 401 with a cert     | Cert auth not registered or scheme mismatch                                         | Ensure [Add-KrClientCertificateAuthentication][Add-KrClientCertificateAuthentication] and route uses `-AuthorizationScheme 'Certificate'` |

## References

- [New-KrServer][New-KrServer]
- [New-KrSelfSignedCertificate][New-KrSelfSignedCertificate]
- [Export-KrCertificate][Export-KrCertificate]
- [Import-KrCertificate][Import-KrCertificate]
- [Set-KrServerHttpsOptions][Set-KrServerHttpsOptions]
- [Add-KrEndpoint][Add-KrEndpoint]
- [Add-KrClientCertificateAuthentication][Add-KrClientCertificateAuthentication]
- [Enable-KrConfiguration][Enable-KrConfiguration]
- [Add-KrMapRoute][Add-KrMapRoute]
- [Write-KrJsonResponse][Write-KrJsonResponse]
- [Start-KrServer][Start-KrServer]

---

### Previous / Next

{: .fs-4 .fw-500}

- Previous: [Claims & Policies][Prev]
- Next: [OpenID Connect (Okta)][Next]

[8.8-Client-Certificate-Authentication.ps1]: /pwsh/tutorial/examples/8.8-Client-Certificate-Authentication.ps1
[New-KrServer]: /pwsh/cmdlets/New-KrServer
[New-KrSelfSignedCertificate]: /pwsh/cmdlets/New-KrSelfSignedCertificate
[Export-KrCertificate]: /pwsh/cmdlets/Export-KrCertificate
[Import-KrCertificate]: /pwsh/cmdlets/Import-KrCertificate
[Set-KrServerHttpsOptions]: /pwsh/cmdlets/Set-KrServerHttpsOptions
[Add-KrEndpoint]: /pwsh/cmdlets/Add-KrEndpoint
[Add-KrClientCertificateAuthentication]: /pwsh/cmdlets/Add-KrClientCertificateAuthentication
[Enable-KrConfiguration]: /pwsh/cmdlets/Enable-KrConfiguration
[Add-KrMapRoute]: /pwsh/cmdlets/Add-KrMapRoute
[Write-KrJsonResponse]: /pwsh/cmdlets/Write-KrJsonResponse
[Start-KrServer]: /pwsh/cmdlets/Start-KrServer
[Prev]: ./7.Claims-Policies
[Next]: ./9.OpenID-Connect-Okta

- Previous: [Claims & Policies][Prev]
- Next: [OpenID Connect (Okta)][Next]
