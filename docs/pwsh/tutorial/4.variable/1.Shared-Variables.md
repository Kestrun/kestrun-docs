---
title: Using Shared Variables
parent: Shared Variable
nav_order: 1
---

# Using Shared Variables Across Routes

Share in-memory state (counters, caches, configuration) by defining variables **before** `Enable-KrConfiguration`
so route script blocks can reference them at execution time.

> Prerequisites: see [Introduction][Introduction]. Ensure `Add-KrPowerShellRuntime` is used so PowerShell
> routes execute.

## Full source

File: [`pwsh/tutorial/examples/4.1-Shared-Variables.ps1`][4.1-Shared-Variables.ps1]

```powershell
{% include examples/pwsh/4.1-Shared-Variables.ps1 %}
```

## Step-by-step

1. Initialize root: `Initialize-KrRoot -Path $PSScriptRoot` for predictable relative paths.
2. Server & listener: `New-KrServer`; `Add-KrListener -Port 5000 -IPAddress Loopback`.
3. Runtime: `Add-KrPowerShellRuntime` so PowerShell routes execute.
4. Declare shared variables BEFORE enabling configuration:
    - `$Visits = [ConcurrentDictionary[string,int]]::new()` stores counts across requests.
    - `$Delay = 1` simulates work to trigger multiple runspaces.
5. Apply config: `Enable-KrConfiguration` freezes the configuration graph.
6. Map routes that use the shared variables:
    - GET `/show` returns the current visit count using `$Visits.Count`.
    - GET `/visit` sleeps for `$Delay` and increments `$Visits` using `AddOrUpdate`.
7. Start: `Start-KrServer`.

Behavior contract

- Inputs: two GET routes (`/show`, `/visit`). No body required.
- Outputs: text/plain responses; `/show` reports current count; `/visit` increments then reports.
- Shared state: variables declared pre-Enable are captured and shared across request runspaces.

## How sharing works

Route script blocks capture the parent (script) scope at registration time. Variables created before
`Enable-KrConfiguration` are available inside each runspace used to handle requests. Mutable reference types
remain shared — all routes see the same underlying instance.

### Choose thread-safe types

Use `ConcurrentDictionary` (or other thread-safe collections) for shared mutations. Avoid plain hashtables for
concurrent writes. Primitive value types (like an `[int]` variable) are copied into each runspace rather than
shared by reference, so incrementing a plain `$Counter` won't reflect across runspaces. Wrap numeric
state in a shared mutable object (e.g., store under a key in a `ConcurrentDictionary`) if it must be updated
concurrently.

### Access patterns

```powershell
# Read current value
$count = $Visits.Count

# Naive increment (ok for demo, not atomic for mixed operations):
$Visits.Count++

# Keyed counter (atomic style)
$null = $Visits.AddOrUpdate('total', 1, { param($k,$v) $v + 1 })

# Atomic increment loop ("clunky" style)
do {
    $oldVal = $Visits['total']
    $newVal = $oldVal + 1
} while (-not $Visits.TryUpdate('total', $newVal, $oldVal))
```

## Common pitfalls

| Pitfall                    | Symptom                       | Fix                                              |
|----------------------------|-------------------------------|--------------------------------------------------|
| Plain hashtable for writes | Lost / inconsistent updates   | Use `ConcurrentDictionary` or locking            |
| Variable defined too late  | `$null` inside routes         | Move declaration before `Enable-KrConfiguration` |
| Variable name shadowed     | Local variable with same name | Use a different local name or explicit scope     |
| Heavy synchronous logic    | Slow responses                | Offload to background job / queue                |

## Try it

Save the sample locally so it’s easy to run. Copy the contents of
[`pwsh/tutorial/examples/4.1-Shared-Variables.ps1`](pwsh/tutorial/examples/4.1-Shared-Variables.ps1)
into a new file in an empty working folder (for example, `shared-vars.ps1`), then run:

```powershell
# From your working folder
pwsh .\shared-vars.ps1
```

Now simulate concurrent visits (100 requests) to see the shared counter increment:

```powershell
(1..100 | ForEach-Object { Start-Job { Invoke-WebRequest -Uri 'http://127.0.0.1:5000/visit' } } |
    Receive-Job -Wait -AutoRemoveJob).Content
```

## Advanced: custom services

You can assign a custom class instance (cache, metrics aggregator, etc.) to a variable pre-configuration and
expose its methods through routes. Ensure internal synchronization if it mutates shared state.

## Best practices

- Keep state minimal; externalize durable data.
- Prefer thread-safe / immutable structures.
- Validate inputs before mutating shared objects.
- Avoid large synchronized regions; keep per-request critical work small.

## Troubleshooting

| Symptom             | Cause                        | Resolution                        |
|---------------------|------------------------------|-----------------------------------|
| Variable is `$null` | Declared after configuration | Declare earlier                   |
| Inconsistent data   | Non-thread-safe structure    | Use thread-safe type              |
| High CPU            | Busy loop / heavy work       | Throttle or move off request path |
| Memory growth       | Unbounded keys               | Evict or cap size                 |

## Cmdlet references

- [Add-KrPowerShellRuntime][Add-KrPowerShellRuntime]
- [Add-KrMapRoute][Add-KrMapRoute]
- [Enable-KrConfiguration][Enable-KrConfiguration]
- [New-KrServer][New-KrServer]
- [Add-KrListener][Add-KrListener]
- [Start-KrServer][Start-KrServer]

---

### Next

{: .fs-4 .fw-500}

Previous: [Adding a Favicon](../3.static/4.Favicon)
Next: [Logging](../5.logging/index)

[4.1-Shared-Variables.ps1]: /pwsh/tutorial/examples/4.1-Shared-Variables.ps1
[Add-KrPowerShellRuntime]: /pwsh/cmdlets/Add-KrPowerShellRuntime
[Add-KrMapRoute]: /pwsh/cmdlets/Add-KrMapRoute
[Enable-KrConfiguration]: /pwsh/cmdlets/Enable-KrConfiguration
[New-KrServer]: /pwsh/cmdlets/New-KrServer
[Add-KrListener]: /pwsh/cmdlets/Add-KrListener
[Start-KrServer]: /pwsh/cmdlets/Start-KrServer
[Introduction]: ../1.introduction/index#prerequisites
