---
title: Response Compression
parent: Middleware
nav_order: 2
---

# Response Compression Middleware

Reduce payload size (bandwidth + latency) for text-based responses by enabling
HTTP content encoding (gzip, brotli, deflate) when the client sends an
`Accept-Encoding` header.

The compression middleware sits early in the pipeline and, for eligible MIME types, wraps the response body stream so data is compressed on-the-fly.

| Aspect | Details |
|--------|---------|
| Enabled For HTTPS | Yes (opt-in with `-EnableForHttps`) |
| Negotiation | Chooses first supported algorithm from client `Accept-Encoding` (br, gzip, deflate) |
| Typical Savings | 60–95% for verbose JSON / HTML / XML payloads |
| CPU Cost | Low for gzip, higher for brotli (better ratio) |
| Skip Heuristics | Very small bodies may be skipped (no `Content-Encoding`) |

> Binary formats (e.g. already-compressed images) are not included by default; focus on text-centric content types.

## Sample Script (10.2-Compression.ps1)

```powershell
{% include examples/pwsh/10.2-Compression.ps1 %}
```

## Routes Overview

| Route | Type | Notes |
|-------|------|-------|
| `/text` | text/plain | Large repeated block >1KB |
| `/json` | application/json | Array of objects (n=150) |
| `/html` | text/html | Many `<p>` tags to grow payload |
| `/xml` | application/xml | Serialized collection |
| `/form` | application/x-www-form-urlencoded | Key=value pairs joined with & |
| `/info` | application/json | Echoes `Accept-Encoding` to aid debugging |

## How Negotiation Works

1. Client sends `Accept-Encoding: br, gzip, deflate` (order denotes preference).
2. Server picks first matching implementation it supports.
3. Middleware sets `Content-Encoding` header and compresses the body stream.
4. Size-sensitive heuristics (or excluded MIME type) → response left uncompressed.

## Trying It Out

Open a terminal and run the sample (PowerShell 7+):

```powershell
pwsh .\docs\_includes\examples\pwsh\10.2-Compression.ps1
```

Then exercise routes (add `-Headers @{ 'Accept-Encoding'='gzip' }` or include brotli):

```powershell
# Plain text
(Invoke-WebRequest https://127.0.0.1:5000/text -SkipCertificateCheck -Headers @{ 'Accept-Encoding'='gzip' }).Headers.'Content-Encoding'

# JSON
(Invoke-WebRequest https://127.0.0.1:5000/json -SkipCertificateCheck -Headers @{ 'Accept-Encoding'='br, gzip' }).Headers.'Content-Encoding'

# HTML
(Invoke-WebRequest https://127.0.0.1:5000/html -SkipCertificateCheck -Headers @{ 'Accept-Encoding'='gzip' }).Headers.'Content-Encoding'

# Info (see what you sent)
Invoke-RestMethod https://127.0.0.1:5000/info -SkipCertificateCheck -Headers @{ 'Accept-Encoding'='gzip' }
```

## Testing Strategy

Key assertions for automated tests:

- Eligible routes return status 200.
- Without `Accept-Encoding`, either no `Content-Encoding` or allowed default.
- With `Accept-Encoding: gzip`, response includes `Content-Encoding: gzip` for large bodies.
- `/info` reflects the header value.
- Body lengths differ (compressed smaller) — len(compressed) < len(uncompressed) for same route.

## Disabling / Tuning

Omit routes or MIME types not desired:

```powershell
Add-KrCompressionMiddleware -MimeTypes @('text/plain','application/json')
```

Skip HTTPS compression by removing `-EnableForHttps` (some platforms historically
disabled HTTPS compression to mitigate certain attacks; modern mitigations usually
make it safe for typical APIs).

## Troubleshooting

| Symptom | Cause | Fix |
|---------|-------|-----|
| No Content-Encoding header | Body below minimum size / MIME type excluded | Increase payload size or add MIME type |
| Large CPU increase | Brotli at high quality | Prefer gzip in latency-sensitive APIs |
| Double compression | Reverse proxy already compressing | Disable at one layer |

## Next

Continue to [Rate Limiting (planned)](./3.Rate-Limiting) or return to the [Middleware index](./index).
